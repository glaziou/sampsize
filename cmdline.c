/*****
  command line parser -- generated by clig
  (http://wsd.iitb.fhg.de/~kir/clighome/)

  The command line parser `clig':
  (C) 1995---2001 Harald Kirsch (kirschh@lionbioscience.com)
*****/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <float.h>
#include <math.h>

#include "cmdline.h"

char *Program;

/*@-null*/

static Cmdline cmd = {
  /***** -h: show usage information */
  /* show_helpP = */ 0,
  /***** -v: show program version */
  /* show_versionP = */ 0,
  /***** -onesided: one-sided test for comparisons */
  /* onesidedP = */ 0,
  /***** -onesample: one-sample test */
  /* onesampleP = */ 0,
  /***** -matched: 1:1 matched case-control study */
  /* matchedP = */ 0,
  /***** -cc: continuity correction */
  /* correctionP = */ 0,
  /***** -pop: target population size */
  /* popP = */ 1,
  /* pop = */ 0,
  /* popC = */ 1,
  /***** -e: precision of estimate (%) -- prevalence study option */
  /* precisionP = */ 0,
  /* precision = */ (float) 0,
  /* precisionC = */ 0,
  /***** -pr: prevalence (%) -- prevalence study option */
  /* prevalenceP = */ 1,
  /* prevalence = */ 50,
  /* prevalenceC = */ 1,
  /***** -level: level of confidence interval (%) */
  /* levelP = */ 1,
  /* level = */ 95,
  /* levelC = */ 1,
  /***** -alpha: Risk alpha (%) */
  /* alphaP = */ 1,
  /* alpha = */ 5,
  /* alphaC = */ 1,
  /***** -power: Power of the test (%) */
  /* powerP = */ 1,
  /* power = */ 90,
  /* powerC = */ 1,
  /***** -c: number of controls per case, to be used with case control options */
  /* ratioP = */ 1,
  /* ratio = */ 1,
  /* ratioC = */ 1,
  /***** -or: Odds Ratio -- case-control study option */
  /* odds_ratioP = */ 0,
  /* odds_ratio = */ (float) 0,
  /* odds_ratioC = */ 0,
  /***** -exp: Exposed controls (%) -- case-control study option */
  /* exposedP = */ 0,
  /* exposed = */ (float) 0,
  /* exposedC = */ 0,
  /***** -cp: #p1 (%) #p2 (%) -- two sample comparison of percentages */
  /* compP = */ 0,
  /* comp = */ (float *) 0,
  /* compC = */ 0,
  /***** -means: #m1 #m2 #sd1 #sd2 -- two sample comparison of means */
  /* meansP = */ 0,
  /* means = */ (float *) 0,
  /* meansC = */ 0,
  /***** -rho: intraclass correlation coefficient -- cluster option */
  /* rhoP = */ 1,
  /* rho = */ 0,
  /* rhoC = */ 1,
  /***** -d: delta critical value -- equivalence */
  /* deltaP = */ 0,
  /* delta = */ (float) 0,
  /* deltaC = */ 0,
  /***** -nob: minimum number of events observed in the sample */
  /* observedP = */ 0,
  /* observed = */ (int) 0,
  /* observedC = */ 0,
  /***** -bi: #obs #succ (binomial events, #obs >= #succ) */
  /* binomialP = */ 0,
  /* binomial = */ (int *) 0,
  /* binomialC = */ 0,
  /***** -n: determine power from sample size */
  /* sampleP = */ 0,
  /* sample = */ (int) 0,
  /* sampleC = */ 0,
  /***** -obsclus: number of observations per cluster */
  /* obsclusP = */ 0,
  /* obsclus = */ (int) 0,
  /* obsclusC = */ 0,
  /***** -numclus: minimum number of clusters */
  /* numclusP = */ 0,
  /* numclus = */ (int) 0,
  /* numclusC = */ 0,
  /***** uninterpreted rest of command line */
  /* argc = */ 0,
  /* argv = */ (char **) 0,
  /***** the original command line concatenated */
  /* tool = */ NULL
};

/*@=null*/

/***** let LCLint run more smoothly */
/*@-predboolothers*/
/*@-boolops*/


/******************************************************************/
/*****
 This is a bit tricky. We want to make a difference between overflow
 and underflow and we want to allow v==Inf or v==-Inf but not
 v>FLT_MAX. 

 We don't use fabs to avoid linkage with -lm.
*****/
static void
checkFloatConversion (double v, char *option, char *arg)
{
  char *err = NULL;

  if ((errno == ERANGE && v != 0.0)	/* even double overflowed */
      || (v < HUGE_VAL && v > -HUGE_VAL
	  && (v < 0.0 ? -v : v) > (double) FLT_MAX))
    {
      err = "large";
    }
  else if ((errno == ERANGE && v == 0.0)
	   || (v != 0.0 && (v < 0.0 ? -v : v) < (double) FLT_MIN))
    {
      err = "small";
    }
  if (err)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of option `%s' to %s to represent\n",
	       Program, arg, option, err);
      exit (EXIT_FAILURE);
    }
}

int
getIntOpt (int argc, char **argv, int i, int *value, int force)
{
  char *end;
  long v;

  if (++i >= argc)
    goto nothingFound;

  errno = 0;
  v = strtol (argv[i], &end, 0);

  /***** check for conversion error */
  if (end == argv[i])
    goto nothingFound;

  /***** check for surplus non-whitespace */
  while (isspace ((int) *end))
    end += 1;
  if (*end)
    goto nothingFound;

  /***** check if it fits into an int */
  if (errno == ERANGE || v > (long) INT_MAX || v < (long) INT_MIN)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of option `%s' to large to represent\n",
	       Program, argv[i], argv[i - 1]);
      exit (EXIT_FAILURE);
    }
  *value = (int) v;

  return i;

nothingFound:
  if (!force)
    return i - 1;

  fprintf (stderr,
	   "%s: missing or malformed integer value after option `%s'\n",
	   Program, argv[i - 1]);
  exit (EXIT_FAILURE);
}

/**********************************************************************/

int
getIntOpts (int argc, char **argv, int i, int **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;
  long v;
  if (i + cmin >= argc)
    {
      fprintf (stderr,
	       "%s: option `%s' wants at least %d parameters\n",
	       Program, argv[i], cmin);
      exit (EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
  alloced = cmin + 4;
  *values = (int *) calloc ((size_t) alloced, sizeof (int));
  if (!*values)
    {
    outMem:
      fprintf (stderr,
	       "%s: out of memory while parsing option `%s'\n",
	       Program, argv[i]);
      exit (EXIT_FAILURE);
    }

  for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++)
    {
      if (used == alloced)
	{
	  alloced += 8;
	  *values = (int *) realloc (*values, alloced * sizeof (int));
	  if (!*values)
	    goto outMem;
	}

      errno = 0;
      v = strtol (argv[used + i + 1], &end, 0);

    /***** check for conversion error */
      if (end == argv[used + i + 1])
	break;

    /***** check for surplus non-whitespace */
      while (isspace ((int) *end))
	end += 1;
      if (*end)
	break;

    /***** check for overflow */
      if (errno == ERANGE || v > (long) INT_MAX || v < (long) INT_MIN)
	{
	  fprintf (stderr,
		   "%s: parameter `%s' of option `%s' to large to represent\n",
		   Program, argv[i + used + 1], argv[i]);
	  exit (EXIT_FAILURE);
	}

      (*values)[used] = (int) v;

    }

  if (used < cmin)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of `%s' should be an "
	       "integer value\n", Program, argv[i + used + 1], argv[i]);
      exit (EXIT_FAILURE);
    }

  return i + used;
}

/**********************************************************************/

int
getLongOpt (int argc, char **argv, int i, long *value, int force)
{
  char *end;

  if (++i >= argc)
    goto nothingFound;

  errno = 0;
  *value = strtol (argv[i], &end, 0);

  /***** check for conversion error */
  if (end == argv[i])
    goto nothingFound;

  /***** check for surplus non-whitespace */
  while (isspace ((int) *end))
    end += 1;
  if (*end)
    goto nothingFound;

  /***** check for overflow */
  if (errno == ERANGE)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of option `%s' to large to represent\n",
	       Program, argv[i], argv[i - 1]);
      exit (EXIT_FAILURE);
    }
  return i;

nothingFound:
  /***** !force means: this parameter may be missing.*/
  if (!force)
    return i - 1;

  fprintf (stderr,
	   "%s: missing or malformed value after option `%s'\n",
	   Program, argv[i - 1]);
  exit (EXIT_FAILURE);
}

/**********************************************************************/

int
getLongOpts (int argc, char **argv, int i, long **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if (i + cmin >= argc)
    {
      fprintf (stderr,
	       "%s: option `%s' wants at least %d parameters\n",
	       Program, argv[i], cmin);
      exit (EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values. It does not hurt to have room
    for a bit more values than cmax.
  *****/
  alloced = cmin + 4;
  *values = calloc ((size_t) alloced, sizeof (long));
  if (!*values)
    {
    outMem:
      fprintf (stderr,
	       "%s: out of memory while parsing option `%s'\n",
	       Program, argv[i]);
      exit (EXIT_FAILURE);
    }

  for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++)
    {
      if (used == alloced)
	{
	  alloced += 8;
	  *values = realloc (*values, alloced * sizeof (long));
	  if (!*values)
	    goto outMem;
	}

      errno = 0;
      (*values)[used] = strtol (argv[used + i + 1], &end, 0);

    /***** check for conversion error */
      if (end == argv[used + i + 1])
	break;

    /***** check for surplus non-whitespace */
      while (isspace ((int) *end))
	end += 1;
      if (*end)
	break;

    /***** check for overflow */
      if (errno == ERANGE)
	{
	  fprintf (stderr,
		   "%s: parameter `%s' of option `%s' to large to represent\n",
		   Program, argv[i + used + 1], argv[i]);
	  exit (EXIT_FAILURE);
	}

    }

  if (used < cmin)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of `%s' should be an "
	       "integer value\n", Program, argv[i + used + 1], argv[i]);
      exit (EXIT_FAILURE);
    }

  return i + used;
}

/**********************************************************************/

int
getFloatOpt (int argc, char **argv, int i, float *value, int force)
{
  char *end;
  double v;

  if (++i >= argc)
    goto nothingFound;

  errno = 0;
  v = strtod (argv[i], &end);

  /***** check for conversion error */
  if (end == argv[i])
    goto nothingFound;

  /***** check for surplus non-whitespace */
  while (isspace ((int) *end))
    end += 1;
  if (*end)
    goto nothingFound;

  /***** check for overflow */
  checkFloatConversion (v, argv[i - 1], argv[i]);

  *value = (float) v;

  return i;

nothingFound:
  if (!force)
    return i - 1;

  fprintf (stderr,
	   "%s: missing or malformed float value after option `%s'\n",
	   Program, argv[i - 1]);
  exit (EXIT_FAILURE);

}

/**********************************************************************/

int
getFloatOpts (int argc, char **argv, int i,
	      float **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;
  double v;

  if (i + cmin >= argc)
    {
      fprintf (stderr,
	       "%s: option `%s' wants at least %d parameters\n",
	       Program, argv[i], cmin);
      exit (EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values.
  *****/
  alloced = cmin + 4;
  *values = (float *) calloc ((size_t) alloced, sizeof (float));
  if (!*values)
    {
    outMem:
      fprintf (stderr,
	       "%s: out of memory while parsing option `%s'\n",
	       Program, argv[i]);
      exit (EXIT_FAILURE);
    }

  for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++)
    {
      if (used == alloced)
	{
	  alloced += 8;
	  *values = (float *) realloc (*values, alloced * sizeof (float));
	  if (!*values)
	    goto outMem;
	}

      errno = 0;
      v = strtod (argv[used + i + 1], &end);

    /***** check for conversion error */
      if (end == argv[used + i + 1])
	break;

    /***** check for surplus non-whitespace */
      while (isspace ((int) *end))
	end += 1;
      if (*end)
	break;

    /***** check for overflow */
      checkFloatConversion (v, argv[i], argv[i + used + 1]);

      (*values)[used] = (float) v;
    }

  if (used < cmin)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of `%s' should be a "
	       "floating-point value\n",
	       Program, argv[i + used + 1], argv[i]);
      exit (EXIT_FAILURE);
    }

  return i + used;
}

/**********************************************************************/

int
getDoubleOpt (int argc, char **argv, int i, double *value, int force)
{
  char *end;

  if (++i >= argc)
    goto nothingFound;

  errno = 0;
  *value = strtod (argv[i], &end);

  /***** check for conversion error */
  if (end == argv[i])
    goto nothingFound;

  /***** check for surplus non-whitespace */
  while (isspace ((int) *end))
    end += 1;
  if (*end)
    goto nothingFound;

  /***** check for overflow */
  if (errno == ERANGE)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of option `%s' to %s to represent\n",
	       Program, argv[i], argv[i - 1],
	       (*value == 0.0 ? "small" : "large"));
      exit (EXIT_FAILURE);
    }

  return i;

nothingFound:
  if (!force)
    return i - 1;

  fprintf (stderr,
	   "%s: missing or malformed value after option `%s'\n",
	   Program, argv[i - 1]);
  exit (EXIT_FAILURE);

}

/**********************************************************************/

int
getDoubleOpts (int argc, char **argv, int i,
	       double **values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;
  char *end;

  if (i + cmin >= argc)
    {
      fprintf (stderr,
	       "%s: option `%s' wants at least %d parameters\n",
	       Program, argv[i], cmin);
      exit (EXIT_FAILURE);
    }

  /***** 
    alloc a bit more than cmin values.
  *****/
  alloced = cmin + 4;
  *values = (double *) calloc ((size_t) alloced, sizeof (double));
  if (!*values)
    {
    outMem:
      fprintf (stderr,
	       "%s: out of memory while parsing option `%s'\n",
	       Program, argv[i]);
      exit (EXIT_FAILURE);
    }

  for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++)
    {
      if (used == alloced)
	{
	  alloced += 8;
	  *values = (double *) realloc (*values, alloced * sizeof (double));
	  if (!*values)
	    goto outMem;
	}

      errno = 0;
      (*values)[used] = strtod (argv[used + i + 1], &end);

    /***** check for conversion error */
      if (end == argv[used + i + 1])
	break;

    /***** check for surplus non-whitespace */
      while (isspace ((int) *end))
	end += 1;
      if (*end)
	break;

    /***** check for overflow */
      if (errno == ERANGE)
	{
	  fprintf (stderr,
		   "%s: parameter `%s' of option `%s' to %s to represent\n",
		   Program, argv[i + used + 1], argv[i],
		   ((*values)[used] == 0.0 ? "small" : "large"));
	  exit (EXIT_FAILURE);
	}

    }

  if (used < cmin)
    {
      fprintf (stderr,
	       "%s: parameter `%s' of `%s' should be a "
	       "double value\n", Program, argv[i + used + 1], argv[i]);
      exit (EXIT_FAILURE);
    }

  return i + used;
}

/**********************************************************************/

/**
  force will be set if we need at least one argument for the option.
*****/
int
getStringOpt (int argc, char **argv, int i, char **value, int force)
{
  i += 1;
  if (i >= argc)
    {
      if (force)
	{
	  fprintf (stderr, "%s: missing string after option `%s'\n",
		   Program, argv[i - 1]);
	  exit (EXIT_FAILURE);
	}
      return i - 1;
    }

  if (!force && argv[i][0] == '-')
    return i - 1;
  *value = argv[i];
  return i;
}

/**********************************************************************/

int
getStringOpts (int argc, char **argv, int i,
	       char ***values, int cmin, int cmax)
/*****
  We want to find at least cmin values and at most cmax values.
  cmax==-1 then means infinitely many are allowed.
*****/
{
  int alloced, used;

  if (i + cmin >= argc)
    {
      fprintf (stderr,
	       "%s: option `%s' wants at least %d parameters\n",
	       Program, argv[i], cmin);
      exit (EXIT_FAILURE);
    }

  alloced = cmin + 4;

  *values = (char **) calloc ((size_t) alloced, sizeof (char *));
  if (!*values)
    {
    outMem:
      fprintf (stderr,
	       "%s: out of memory during parsing of option `%s'\n",
	       Program, argv[i]);
      exit (EXIT_FAILURE);
    }

  for (used = 0; (cmax == -1 || used < cmax) && used + i + 1 < argc; used++)
    {
      if (used == alloced)
	{
	  alloced += 8;
	  *values = (char **) realloc (*values, alloced * sizeof (char *));
	  if (!*values)
	    goto outMem;
	}

      if (used >= cmin && argv[used + i + 1][0] == '-')
	break;
      (*values)[used] = argv[used + i + 1];
    }

  if (used < cmin)
    {
      fprintf (stderr,
	       "%s: less than %d parameters for option `%s', only %d found\n",
	       Program, cmin, argv[i], used);
      exit (EXIT_FAILURE);
    }

  return i + used;
}

/**********************************************************************/

void
checkIntLower (char *opt, int *values, int count, int max)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] <= max)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' greater than max=%d\n",
	       Program, i + 1, opt, max);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

void
checkIntHigher (char *opt, int *values, int count, int min)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] >= min)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' smaller than min=%d\n",
	       Program, i + 1, opt, min);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

void
checkLongLower (char *opt, long *values, int count, long max)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] <= max)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' greater than max=%ld\n",
	       Program, i + 1, opt, max);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

void
checkLongHigher (char *opt, long *values, int count, long min)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] >= min)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' smaller than min=%ld\n",
	       Program, i + 1, opt, min);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

void
checkFloatLower (char *opt, float *values, int count, float max)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] <= max)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' greater than max=%f\n",
	       Program, i + 1, opt, max);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

void
checkFloatHigher (char *opt, float *values, int count, float min)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] >= min)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' smaller than min=%f\n",
	       Program, i + 1, opt, min);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

void
checkDoubleLower (char *opt, double *values, int count, double max)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] <= max)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' greater than max=%f\n",
	       Program, i + 1, opt, max);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

void
checkDoubleHigher (char *opt, double *values, int count, double min)
{
  int i;

  for (i = 0; i < count; i++)
    {
      if (values[i] >= min)
	continue;
      fprintf (stderr,
	       "%s: parameter %d of option `%s' smaller than min=%f\n",
	       Program, i + 1, opt, min);
      exit (EXIT_FAILURE);
    }
}

/**********************************************************************/

static char *
catArgv (int argc, char **argv)
{
  int i;
  size_t l;
  char *s, *t;

  for (i = 0, l = 0; i < argc; i++)
    l += (1 + strlen (argv[i]));
  s = (char *) malloc (l);
  if (!s)
    {
      fprintf (stderr, "%s: out of memory\n", Program);
      exit (EXIT_FAILURE);
    }
  strcpy (s, argv[0]);
  t = s;
  for (i = 1; i < argc; i++)
    {
      t = t + strlen (t);
      *t++ = ' ';
      strcpy (t, argv[i]);
    }
  return s;
}

/**********************************************************************/

void
usage (void)
{
  fprintf (stderr, "usage: %s%s", Program, "\
 [-h] [-v] [-onesided] [-onesample] [-matched] [-cc] [-pop pop] [-e precision] [-pr prevalence] [-level level] [-alpha alpha] [-power power] [-c ratio] [-or odds_ratio] [-exp exposed] [-cp comp] [-means means] [-rho rho] [-d delta] [-nob observed] [-bi binomial] [-n sample] [-obsclus obsclus] [-numclus numclus]\n\
    Computes sample size and power\n\
          -h: show usage information\n\
          -v: show program version\n\
   -onesided: one-sided test for comparisons\n\
  -onesample: one-sample test\n\
    -matched: 1:1 matched case-control study\n\
         -cc: continuity correction\n\
        -pop: target population size\n\
              1 float value between 0.0 and oo\n\
              default: `0'\n\
          -e: precision of estimate (%) -- prevalence study option\n\
              1 float value between 0.0 and 100\n\
         -pr: prevalence (%) -- prevalence study option\n\
              1 float value between 0.0 and 100\n\
              default: `50'\n\
      -level: level of confidence interval (%)\n\
              1 float value between 50.0 and 100\n\
              default: `95'\n\
      -alpha: Risk alpha (%)\n\
              1 float value between 0.0 and 100\n\
              default: `5'\n\
      -power: Power of the test (%)\n\
              1 float value between 50.0 and 100\n\
              default: `90'\n\
          -c: number of controls per case, to be used with case control options\n\
              1 float value between 0 and oo\n\
              default: `1'\n\
         -or: Odds Ratio -- case-control study option\n\
              1 float value between 0 and oo\n\
        -exp: Exposed controls (%) -- case-control study option\n\
              1 float value between 0.0 and 100\n\
         -cp: #p1 (%) #p2 (%) -- two sample comparison of percentages\n\
              2 float values between 0 and 100\n\
      -means: #m1 #m2 #sd1 #sd2 -- two sample comparison of means\n\
              3...4 float values\n\
        -rho: intraclass correlation coefficient -- cluster option\n\
              1 float value between 0.0 and 1\n\
              default: `0'\n\
          -d: delta critical value -- equivalence\n\
              1 float value between 0.0 and oo\n\
        -nob: minimum number of events observed in the sample\n\
              1 int value between 1 and 10000\n\
         -bi: #obs #succ (binomial events, #obs >= #succ)\n\
              2 int values between 0 and oo\n\
          -n: determine power from sample size\n\
              1 int value between 1 and oo\n\
    -obsclus: number of observations per cluster\n\
              1 int value between 1 and oo\n\
    -numclus: minimum number of clusters\n\
              1 int value between 1 and oo\n\
version: 0.6.0\n\
");
  exit (EXIT_FAILURE);
}

/**********************************************************************/
Cmdline *
parseCmdline (int argc, char **argv)
{
  int i;

  Program = argv[0];
  cmd.tool = catArgv (argc, argv);
  for (i = 1, cmd.argc = 1; i < argc; i++)
    {
      if (0 == strcmp ("-h", argv[i]))
	{
	  cmd.show_helpP = 1;
	  continue;
	}

      if (0 == strcmp ("-v", argv[i]))
	{
	  cmd.show_versionP = 1;
	  continue;
	}

      if (0 == strcmp ("-onesided", argv[i]))
	{
	  cmd.onesidedP = 1;
	  continue;
	}

      if (0 == strcmp ("-onesample", argv[i]))
	{
	  cmd.onesampleP = 1;
	  continue;
	}

      if (0 == strcmp ("-matched", argv[i]))
	{
	  cmd.matchedP = 1;
	  continue;
	}

      if (0 == strcmp ("-cc", argv[i]))
	{
	  cmd.correctionP = 1;
	  continue;
	}

      if (0 == strcmp ("-pop", argv[i]))
	{
	  int keep = i;
	  cmd.popP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.pop, 1);
	  cmd.popC = i - keep;
	  checkFloatHigher ("-pop", &cmd.pop, cmd.popC, 0.0);
	  continue;
	}

      if (0 == strcmp ("-e", argv[i]))
	{
	  int keep = i;
	  cmd.precisionP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.precision, 1);
	  cmd.precisionC = i - keep;
	  checkFloatLower ("-e", &cmd.precision, cmd.precisionC, 100);
	  checkFloatHigher ("-e", &cmd.precision, cmd.precisionC, 0.0);
	  continue;
	}

      if (0 == strcmp ("-pr", argv[i]))
	{
	  int keep = i;
	  cmd.prevalenceP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.prevalence, 1);
	  cmd.prevalenceC = i - keep;
	  checkFloatLower ("-pr", &cmd.prevalence, cmd.prevalenceC, 100);
	  checkFloatHigher ("-pr", &cmd.prevalence, cmd.prevalenceC, 0.0);
	  continue;
	}

      if (0 == strcmp ("-level", argv[i]))
	{
	  int keep = i;
	  cmd.levelP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.level, 1);
	  cmd.levelC = i - keep;
	  checkFloatLower ("-level", &cmd.level, cmd.levelC, 100);
	  checkFloatHigher ("-level", &cmd.level, cmd.levelC, 50.0);
	  continue;
	}

      if (0 == strcmp ("-alpha", argv[i]))
	{
	  int keep = i;
	  cmd.alphaP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.alpha, 1);
	  cmd.alphaC = i - keep;
	  checkFloatLower ("-alpha", &cmd.alpha, cmd.alphaC, 100);
	  checkFloatHigher ("-alpha", &cmd.alpha, cmd.alphaC, 0.0);
	  continue;
	}

      if (0 == strcmp ("-power", argv[i]))
	{
	  int keep = i;
	  cmd.powerP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.power, 1);
	  cmd.powerC = i - keep;
	  checkFloatLower ("-power", &cmd.power, cmd.powerC, 100);
	  checkFloatHigher ("-power", &cmd.power, cmd.powerC, 50.0);
	  continue;
	}

      if (0 == strcmp ("-c", argv[i]))
	{
	  int keep = i;
	  cmd.ratioP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.ratio, 1);
	  cmd.ratioC = i - keep;
	  checkFloatHigher ("-c", &cmd.ratio, cmd.ratioC, 0);
	  continue;
	}

      if (0 == strcmp ("-or", argv[i]))
	{
	  int keep = i;
	  cmd.odds_ratioP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.odds_ratio, 1);
	  cmd.odds_ratioC = i - keep;
	  checkFloatHigher ("-or", &cmd.odds_ratio, cmd.odds_ratioC, 0);
	  continue;
	}

      if (0 == strcmp ("-exp", argv[i]))
	{
	  int keep = i;
	  cmd.exposedP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.exposed, 1);
	  cmd.exposedC = i - keep;
	  checkFloatLower ("-exp", &cmd.exposed, cmd.exposedC, 100);
	  checkFloatHigher ("-exp", &cmd.exposed, cmd.exposedC, 0.0);
	  continue;
	}

      if (0 == strcmp ("-cp", argv[i]))
	{
	  int keep = i;
	  cmd.compP = 1;
	  i = getFloatOpts (argc, argv, i, &cmd.comp, 2, 2);
	  cmd.compC = i - keep;
	  checkFloatLower ("-cp", cmd.comp, cmd.compC, 100);
	  checkFloatHigher ("-cp", cmd.comp, cmd.compC, 0);
	  continue;
	}

      if (0 == strcmp ("-means", argv[i]))
	{
	  int keep = i;
	  cmd.meansP = 1;
	  i = getFloatOpts (argc, argv, i, &cmd.means, 3, 4);
	  cmd.meansC = i - keep;
	  continue;
	}

      if (0 == strcmp ("-rho", argv[i]))
	{
	  int keep = i;
	  cmd.rhoP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.rho, 1);
	  cmd.rhoC = i - keep;
	  checkFloatLower ("-rho", &cmd.rho, cmd.rhoC, 1);
	  checkFloatHigher ("-rho", &cmd.rho, cmd.rhoC, 0.0);
	  continue;
	}

      if (0 == strcmp ("-d", argv[i]))
	{
	  int keep = i;
	  cmd.deltaP = 1;
	  i = getFloatOpt (argc, argv, i, &cmd.delta, 1);
	  cmd.deltaC = i - keep;
	  checkFloatHigher ("-d", &cmd.delta, cmd.deltaC, 0.0);
	  continue;
	}

      if (0 == strcmp ("-nob", argv[i]))
	{
	  int keep = i;
	  cmd.observedP = 1;
	  i = getIntOpt (argc, argv, i, &cmd.observed, 1);
	  cmd.observedC = i - keep;
	  checkIntLower ("-nob", &cmd.observed, cmd.observedC, 10000);
	  checkIntHigher ("-nob", &cmd.observed, cmd.observedC, 1);
	  continue;
	}

      if (0 == strcmp ("-bi", argv[i]))
	{
	  int keep = i;
	  cmd.binomialP = 1;
	  i = getIntOpts (argc, argv, i, &cmd.binomial, 2, 2);
	  cmd.binomialC = i - keep;
	  checkIntHigher ("-bi", cmd.binomial, cmd.binomialC, 0);
	  continue;
	}

      if (0 == strcmp ("-n", argv[i]))
	{
	  int keep = i;
	  cmd.sampleP = 1;
	  i = getIntOpt (argc, argv, i, &cmd.sample, 1);
	  cmd.sampleC = i - keep;
	  checkIntHigher ("-n", &cmd.sample, cmd.sampleC, 1);
	  continue;
	}

      if (0 == strcmp ("-obsclus", argv[i]))
	{
	  int keep = i;
	  cmd.obsclusP = 1;
	  i = getIntOpt (argc, argv, i, &cmd.obsclus, 1);
	  cmd.obsclusC = i - keep;
	  checkIntHigher ("-obsclus", &cmd.obsclus, cmd.obsclusC, 1);
	  continue;
	}

      if (0 == strcmp ("-numclus", argv[i]))
	{
	  int keep = i;
	  cmd.numclusP = 1;
	  i = getIntOpt (argc, argv, i, &cmd.numclus, 1);
	  cmd.numclusC = i - keep;
	  checkIntHigher ("-numclus", &cmd.numclus, cmd.numclusC, 1);
	  continue;
	}

      if (argv[i][0] == '-')
	{
	  fprintf (stderr, "\n%s: unknown option `%s'\n\n", Program, argv[i]);
	  usage ();
	}
      argv[cmd.argc++] = argv[i];
    }				/* for i */


  /*@-mustfree */
  cmd.argv = argv + 1;
  /*@=mustfree */
  cmd.argc -= 1;

  if (cmd.argc > 0)
    {
      fprintf (stderr,
	       "%s: There are %d arguments not associated with any option\n",
	       Program, cmd.argc);
      exit (EXIT_FAILURE);
    }
  /*@-compmempass */ return &cmd;
}
